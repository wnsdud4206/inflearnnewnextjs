<!DOCTYPE html>
<html lang="ko">
  <head>
    <title>this의 이해</title>
    <script>
      class ClassCounterPage {
        count = 10

        // 1. bind
        // onClickCountUp() {
        //   console.log("current count: ", this.count);
        // }
        // 2. 화살표 함수
        onClickCountUp = () => {
          console.log("current count: ", this.count);
        }
        
        render() {
          const button = document.createElement("button");
          // button.count = 100;
          // button.addEventListener("click", this.onClickCountUp);
          // 1. bind
          // button.addEventListener("click", this.onClickCountUp.bind(this));
          // 2. 화살표 함수
          button.addEventListener("click", this.onClickCountUp);
          button.innerText = "Increase Count";
          document.body.appendChild(button);
        }
      }
      /*
      지금 보기에 this는 ClassCounterPage class 지만 실행 주체에 따라서 이 this는 언제든지 바뀐다. 무슨 말이냐면 이 문서를 브라우저에서 봤을 때 button을 누르면 그 버튼이 실행 주체가 되어 this는 그 button이 된다. 그래서 위처럼 render 함수 안에 button에게 count는 100이라는 값을 주고 버튼을 눌러보면 console에 10이 아닌 100이 출력되는 것을 확인할 수 있다.
      이렇게 this는 실행 주체에 따라서 달라지기 때문에 복잡하고 어려워하는 부분중에 하나이다. 해결하는 방법은 2가지가 있다.

      1. bind, this를 통해 연결시키는 방법
      함수를 button에게 넘겨줄 때 함수에게 현재의 this를 bind(연결) 해주는 것이다. 나중에 다른 this를 사용하지 말고 현재의 this를 사용하라는 의미인 것이다. 그렇게 되면 실행 주체에 따라서 this가 달라지지 않고 onClickCountUp 함수가 우리가 의도한 this만 사용할 수 있게 된다.

      2. 화살표 함수, 채택
      bind를 사용하다보면 어디는 bind를 사용하고 어디는 사용하지 않고 복잡해질 수 있으므로 애초에 화살표 함수로 만들어 bind 할 필요가 없게 만들어 주면 된다. 화살표 함수는 실행주체에 따라서 달라지는 게 아니라 우리가 의도한 그 this를 그대로 가져와 사용한다.
      */

      window.onload = () => {
        const counter = new ClassCounterPage();
        counter.render();
      }
    </script>
  </head>
  <body>
    
  </body>
</html>